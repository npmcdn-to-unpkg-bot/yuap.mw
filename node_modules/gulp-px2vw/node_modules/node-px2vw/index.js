'use strict';

var postCSS = require('postcss');
var extend = require('extend');

var pxRegExp = /(\d*\.?\d+)px/ig;

var defaults = {
    width: 320,
    rootValue: 16,
    unitPrecision: 5,
    propertyBlackList: [],
    propertyWhiteList: [],
    replace: false,
    mediaQuery: false,
    minPx: 1
};

var o;

var px2vw;

function toVw(value, width) {

    return (value / width) * 100;
}

function toFixed(value) {

    return Math.floor((value) * 100) / 100;
}

function pxReplace(strArg) {
    var str = parseFloat(strArg);

    if (o.minPx >= str) {
        return str + 'px';
    }

    return toFixed(toVw(str, o.width)) + 'vw';
}

function equals(decls, prop, value) {
    return decls.some(function(decl) {
        return (decl.prop === prop && decl.value === value);
    });
}

function px2Vw(options) {
    o = extend(true, {}, defaults, options);
}

px2Vw.prototype.process = function(css, options) {
    return postCSS(this.postCSS).process(css, options).css;
};

px2Vw.prototype.postCSS = function(css) {
    css.walkDecls(function(decl, i) {
        var rule;
        var value;

        if (o.propertyBlackList.indexOf(decl.prop) !== -1) {
            return;
        }

        if (o.propertyWhiteList.length > 0 &&
            o.propertyWhiteList.indexOf(decl.prop) === -1) {
            return;
        }

        rule = decl.parent;
        value = decl.value;

        if (value.indexOf('px') !== -1) {
            value = value.replace(pxRegExp, pxReplace);

            if (equals(rule.nodes, decl.prop, value)) {
                return;
            }

            if (o.replace) {
                decl.value = value;
            } else {
                rule.insertAfter(i, decl.clone({
                    value: value
                }));
            }
        }
    });

    if (o.mediaQuery) {
        css.each(function(rule) {
            if (rule.type !== 'atrule' && rule.name !== 'media') {
                return;
            }

            if (rule.params.indexOf('px') !== -1) {
                rule.params = rule.params.replace(pxRegExp, pxReplace);
            }
        });
    }
};

px2vw = function(options) {
    return new px2Vw(options);
};

px2vw.process = function(css, options, postCSSOptions) {
    return new px2Vw(options).process(css, postCSSOptions);
};

module.exports = px2vw;
